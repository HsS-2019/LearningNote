# 排序算法

## 冒泡排序
使得串行中的各元素如水中逐渐上浮的气泡一般，每一轮都选出当前最大的元素并放在后面。

### 冒泡排序的优化
**思路一：**在剩余的元素中，每次确定最大的元素的过程都会遍历一遍剩余元素，在遍历过程中，记录是否发生了元素交换，若没有，证明整个串行已排好序，跳出循环。  

**思路二：**在每轮循环之后，可以确认，最后一次发生交换的位置之后的元素，都是排好序的，因此可以不再比较那个位置之后的元素，减少比较的次数。  

**思路三：**在上述优化的基础上进行双向循环排序，也叫鸡尾酒排序

## 插入排序
从前到后，每次只处理一个元素，在当前元素的位置往前逐个查找，找到该元素合适的插入位置。  

最好情况下，只需要比较n次，不需要移动，时间复杂度为O（n），最坏情况下是逆向有序，这样每个元素要比较n次，时间复杂度为O（n^ 2）。

## 希尔排序
也称递减增量(缩小增量)排序算法，是插入算法的一种更高效的改进版本，但希尔排序是非稳定的排序算法。

### 算法思想
1. 将长度为n的整个待排序的记录序列按初始增量d=n/2分割成n/d子序列，所有距离为d的倍数的记录放入同一个组中，对各组分别进行插入排序。
- 然后改变增量为原有的一半，继续分组，并进行排序，直到d=1，算法结束。
- 每一次的对d个序列分别完成插入排序后，对应序列变得有序，减少后面需要移动和比较的次数。

## 选择排序

### 算法思想
遍历数组，前i-1个元素是已经排好序的，然后从i到n中选择除最小的，记录下位置，如果不是第i位，则和第i个元素交换位置。这样的做法，可能会让第i个元素排到相等的元素之后，造成排序的不稳定。

## 快速排序

### 算法思想
1. 在数组中随机取一个值作为标兵。
2. 对标兵左、右的区间进行划分（将比标兵大的数放在标兵的右面，比标兵小的数放在标兵的左面，如果倒序就反过来）
3. 重复如上两个过程，直到选取了所有的标兵并划分（此时每个标兵决定的区间中只有一个值，故有序）

### 算法优化
在最坏的情况，即数组刚好和想要的结果顺序相同或相反，每次循环只得到一个比上一次划分少一个记录的子序列，因此时间复杂度为O（n^2）。  

#### 1. 合理选择pivot
三值取平均、随机选取标兵

#### 2. 处理重复元素的问题
分为小于pivot、等于pivot、大于pivot三个分区。

#### 3. 优化小数组
对于规模很小的情况，快排效率较低

#### 4. 优化递归
使用尾递归，减少因递归而造成的内存暴增问题

#### 5. 并行加速
利用多线程，通过并行加快快排的运行

## 堆排序
将数组看成堆，第i个节点的孩子节点为第2*i+1和2*i+2个节点（不超出数组长度）。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。

### 算法思想
1. 构造初始堆：将给定的无序序列构造成一个大顶堆（升序用大顶堆，降序用小顶堆）。
2. 取出顶元素：将堆顶元素与末尾元素交换，将最大元素“沉”到数组末尾。
3. 递归执行：重新调整结构，使其符合堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。

### 时间复杂度分析
堆排序的主要时间花费在初始建堆期间，建好堆后，找到数列中最大的值只需要O（1）的时间复杂度，维护需要logn的时间复杂度,它也是一种不稳定的排序算法。

## 归并排序
分治法的典型应用，将已有序的子序列合并，得到完全有序的序列，是一个建立在归并操作上的稳定的排序算法。速度仅次于快速排序，一般用于总体无序，但是各子项相对有序的数列。

### 实现原理
1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列。
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置。
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置，重复步骤3直到某一指针超出序列尾。
4. 将另一序列剩下的所有元素直接复制到合并序列尾。

## 桶排序
也称箱排序，桶排序要求所排序数据要尽可能均匀地分布在一个范围内，是一种通过牺牲空间来提高效率的的非比较的稳定排序算法。

### 实现原理
将数组分到有限数量的桶子里，每个桶子再分别排序（有可能再使用别的排序算法）。假设要对1～k范围内的n个数排序，即设置桶的数量为K，然后分别编号1-k，标志位记录桶内的数据量，输出时只需要遍历所有桶，选择有数据的桶，并按编号输出即可。

### 缺点
当数据稀疏分布或数据范围过大时，桶排序的空间复杂度很高。

## 计数排序
统计元素频率.然后得出元素对应的开始位置,新建一个同等大小的数组,从元素对应开始位置放进,最后得到排序数组,再复制回原数组.

## 基数排序
基数排序是一种非比较性整数排序算法，基于计数排序原理实现，由于整数也可以表达字符串和特定格式，所以适用很多数据的排序。最高位优先法称为MSD法，最低位优先法称为LSD法。

### 算法思想
其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较一轮。相同值的数放进同一个桶里，然后把这些值重新串接起来。

## 是否为基于比较的排序

### 基于比较的排序
...

### 非基于比较的排序
桶排序、计数排序、基数排序

## 稳定性比较

排序算法 |稳定性  |排序算法 |稳定性  |
:------:|:----:|:------:|:----:|
冒泡排序 |稳定性 |堆排序   |稳定性 |
插入排序 |稳定性 |桶排序   |稳定性 |
希尔排序 |稳定性 |计数排序 |稳定性 |
快速排序 |稳定性 |基数排序 |稳定性 |





