# 

## 编译过程

<!--Note-->
### 编译过程

#### 预处理
- 宏展开和处理条件编译命令
- 包含头文件
- 删除注释 
- 标注文件和行号

#### 编译
- 词法分析
- 语法分析
- 语义分析
- 源代码优化
- 目标代码生成
- 目标代码优化

#### 汇编
- 转换
  - 对照汇编代码-机器代码表,转化成机器代码

#### 链接
- 地址和空间分配

  - 扫描所有的输入目标文件，获得他们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表（符号表里有什么）
  - 链接器将能够获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度与位置，并建立映射关系.映射关系就是指可执行文件与进程虚拟地址空间之间的映射

- 符号决议
  - 将函数和变量等的符号绑定到初始地址
  - 解析符号就是将每个符号引用与它输入的可重定位目标文件中的符号表中的一个确定的符号定义联系起来。
  
- 重定位
  - 绑定到对应内存地址,并把引用指向内存地址
  
#### 参考书籍
  [程序员的自我修养-链接、装载和库]()
<!--/Note-->

## 应用程序分区

<!--Note-->
### 应用程序分区
#### 堆区
- 动态申请的对象空间    
  
#### 栈区
- 局部变量,函数参数,返回地址
---
#### 数据段      
- 只读数据段
  - 全局常量和静态常量
  
- 读写数据段
  - 存放已被初始化的全局变量和静态变量
	
#### BSS
- 未初始化的全局变量和静态变量
  
#### 代码段
- 字面量、源代码
  
#### 注意
- 其实分区存在多种的,例如以前是有BSS分区,而一些博客说现在已经没有这个分区了,又比如C++中还存在一个分区使用于malloc动态申请的空间.

#### 参考博客
[可执行程序中的BSS段](https://blog.csdn.net/songjinshi/article/details/8441067)
<!--/Note-->

## 操作系统中一些常见的问题

<!--Note-->
##### 操作系统中常见的问题
- 堆和栈的区别
  - 效率
    栈由系统自动分配释放,效率更高,但无法手动控制.堆是由程序员动态申请空间分配的,效率较低但操作更自由
  - 空间大小和分布
    栈是连续分配的内存地址,空间较小且固定,堆是离散分布,空间可以动态增加
  - 申请后的响应
    申请空间大于栈剩余空间时会导致栈溢出.而对于堆,首先会在堆中寻找是否存在大于申请空间的区域,若有则分配,没有就检查剩余离散空间合并后是否大于申请空间,若大于,则分配,否则动态增大空间大小以分配
  - 存取内容不同
    栈存放的是函数参数、局部变量、函数返回地址等信息.堆存放的程序员动态申请的对象
- 动态链接和静态链接的区别
  - 发生的时期
    - 静态链接在编译的链接阶段进行
    - 动态链接在编译的链接阶段仅仅加入一些描述信息,在运行时进行链接
  - 是否浪费空间
    - 静态链接会把静态库文件包含到可执行文件中,所以软件体积更大
    - 动态链接仅加入一些描述信息，在运行调用时再把动态库相关文件加载到内存，动态链接常使用于系统库,或多个应用都需要调用的库,为软件“瘦身”
  - 是否更新困难
    - 静态链接更新困难，使用静态链接时，每当要更新库，都要重新编译程序
    - 动态链接更新更简单，由于没有加入到可执行文件,所以动态库更新之后，调用动态库的程序不需要重新编译
  - 动态链接的可重定位
    - 在形成可执行文件时发现引用了一个外部的函数,此时会检查动态链接库,如果这个函数名是一个动态链接符号,此时可执行程序不会对这个符号进行重定位,而把这个过程留到装载时在进行
- debug和release的区别
  - 程序是否能正常调试
    - debug版本保留了断点等调试信息,能正常调试
    - release版本删除了调试信息,所以不能用于调试
  - 程序体积
    - debug版本保留了调试等信息,所以软件包体积更大,所以debug版本又称测试版本
    - 同理可知,release版本体积更小,所以release版本又称发布版本
- 执行main函数前运行的代码
  - 全局变量和静态变量的内存分配
<!--/Note-->
