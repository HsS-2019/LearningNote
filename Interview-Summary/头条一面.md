## 头条一面
- 公司：字节跳动
- 面试轮数：一面
- 面试用时：45分钟左右

### 主要问题
#### 项目部分
   1. 谈一下自己实习期间做的项目。
   2. 项目期间遇到最大的难题是什么。
   3. 项目用了什么第三方库。
   4. 项目使用了什么第三方库？，为什么选用Alamofire网络库而不用系统的？该库封装了什么功能？
     - A：Alamofire的核心主要是简化iOS中HTTP的网络连接。通过Alamofire可以更简单高效地实现与服务器的交互。并且，alamofire是异步调用的，它会自动开启一个线程去执行这个请求。
    使用alamofire更简单，更高效，因为相对于原生的网络请求，alamofire封装了例如返回数据、请求、认证等。
    通过NSURLSession和Foundation URL Loading System来创建一个swift本地的网络接口，从而高效率地执行任务。另外，alamofire在swift中放弃了代理模式取而代之的使用了回调。虽然是异步实现的，但并不建议在主线程上执行。
   5. 除了项目需要的知识，平时还会去学别的关于iOS的知识吗？大概学了什么？
     - A：会学，因为感觉很多都不会。。详细见进阶。
     
#### swift和iOS基础知识：
   1. 什么是扩展，什么是协议，以及两者之间的区别。
    - A：扩展是给一个类型添加一些新的功能，协议是把基类的部分通用功能封装起来，然后继承协议的子类去自定义实现这些功能，实现委托/代理。
   2. swift中类和结构体的区别。
    - A：类是引用类型，结构体是值类型。类实例的赋值是浅拷贝（共享同一份数据），结构体实例的赋值是深拷贝（复制一份副本给新的实例）。
   3. 什么类型可以用扩展，除了类之外，结构体可以吗？枚举可以吗？
    - A：都可以，swift的扩展可以加到任何符合访问权限的数据结构或基本类型上。
   4. swift是动态语言吗？如果是的话，通过什么实现动态这一特性的？（因为我回答了是。。尴尬的问题，事实上后面查资料发现swift对于继承自OC的类或通过dynamic、@objc关键字还是可以使用runtime的）
    - A：OC是一门基于运用时的编程语言，这意味着所有方法、变量、类之间的链接，都会推迟到应用实际运行的最后一刻才会建立，这给了开发人员极高的灵活性。与OC不同的是，swift大多数时候是一门面向编译时的语言，因此在swift中，灵活性受到了限制，不过更安全。所以OC是动态运行时类型语言，有runtime特性。swift是静态语言（部分情况可以使用OC的runtime特性），也是静态类型语言（类型检查在编译执行）。

   5. 学过OC吗？swift与OC之间的区别与联系，怎么通过swift调用OC代码。
    - A：时间有限，没学过OC。OC和swift的区别与联系：
        联系：
        1.Swift的内存管理和OC一样，都是使用自动引用计数（ARC）。
        2.swift中可以调用OC的框架和代码。
        区别：
        1.swift中多了元组类型和泛型。
        2.swift中增加了可选类型这一特性。
        3.swift中新增两种访问权限。
        4.swift支持过程式编程和便捷的函数式编程（Map和reduce）。
        5.swift中增加了范围运算符。
        6.swift中常量和变量的声明方式不一样。
        7.swift有类型推断特性。
        8.swift是类型安全的，并且是强类型语言，OC是弱类型语言。
   6. 通过swift调用OC：
     - 使用cocoapods导入的第三方OC类库在swift项目中可以直接import调用，不需要创建桥接头文件。
     - 一般在swift项目中需要调用OC的代码文件时，需要生成一个统一的桥接文件（可以手动生成或拖拽进项目后自动生成），然后在桥接文件中import引入需要的头文件。
     - 具体使用，按照对应的swift语法结构来即可。
   7. 通过OC调用swift：
     - 在OC文件中加上#import ProjectName-swift.h，这个文件虽然在工程中看不到，但却是真实存在的。引入后，具体类的使用，直接按照OC的方式即可。需要注意的是，需要混编的swift类、方法和属性等需要添加@objc声明，或继承NSObject、NSObject的子类。swift中独有的特性不能在OC中使用。
    
   8. C++程序的编译过程能描述一下吗？描述swift的也可以。
    - A：预处理—编译—汇编—链接，swift同理。

   9. 了解什么设计模式，能详细说说吗？
    - A：iOS常用设计模式，包括：单例模式、装饰者模式、观察者模式、MVC模式。详细说了下装饰者模式的使用。
    
#### 算法：
   1. 知道LRU算法吗？用你熟悉的语言实现一下这个算法。
    - A：最近最少使用算法，相关的还有LFU算法，LFU是最近最不常用算法。前者是按照记录的访问时间来排序，首先检查是否命中，其它考虑缓存是否已经满了，淘汰最长时间未被使用的项。后者是淘汰一定时间内访问次数最少的项。
    - 实现：可用链表或数组实现，首选链表。
    
## 扩展1—认识语言类型
- 编译型语言，先将源代码编译生成机器指令，再由机器运行机器码。在程序执行之前需一个专门的编译过程。运行时无需再编译。程序执行速度快，但跨平台性不够好。  
- 编译型语言的优缺点：  
   1. 优点：编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高。可以脱离语言环境独立运行。
   2. 缺点：编译之后，如果需要更改代码，就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。  
    代表语言：C、C++、Pascal、OC、Swift
- 解释型语言，源代码不是直接翻译成机器指令，而是先翻译成中间代码，再由解释器对中间代码进行解释运行。运行前无需编译，在运行程序的时候，解释型语言必须先解释再运行。程序执行速度慢，但跨平台性好。
- 解释性语言的优缺点：
   1. 优点：良好的平台兼容性，在任何环境都能运行，前提是安装了解释器。灵活，修改代码的时候直接修改即可，
   2. 缺点：每次运行的时候都要重新解释一遍，性能上不如编译型语言。  
    代表语言：Javascript、python、Erlang、PHP、Perl、Ruby。
- 混合型语言：C#，在编译的时候不是直接编译成机器码而是中间码。Java，先生成字节码再在Java虚拟机中解释执行。  
- 动态语言：在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，引进的函数可以被删除或是其它结构上的变化。另外，类型的检查实在运行时执行的。
    1. 优点：方便阅读，清晰明了。
    2. 缺点：不方便调试。  
    代表语言：OC、JavaScript、PHP、Python、Erlang。
- 静态语言：与动态语言相对应的是，运行时结构不可变的语言就是静态语言。静态语言的类型判断实在运行前判断的（编译阶段），另外，是不是动态语言与这门语言是不是类型安全的完全不相干。
    优点：结构非常规范、便于调试、方便类型安全。
    缺点：需要写更多的类型相关代码，导致代码不便于阅读，不清晰明了。  
    代表语言：Java、C、C++、C#。
- 静态语言和动态语言的区别：
  1. 运行时结构是否可以改变。动态语言可改变，静态结构不可改变。
  2. 是否支持类型检查，动态语言不支持，静态语言支持。
  3. 动态类型语言 和静态类型语言区别在于 语言类型是运行前确定还是运行时声明（即类型检查在程序运行时还是编译时做的）。
  
参考资料1：[各种类型区分参考资料](https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80)  
参考资料2：[swift和OC的运行时特性参考资料](https://www.cnblogs.com/taoxu/p/7975984.html)  
## 扩展2—c++程序的编译过程
- 预处理：处理条件编译命令，头文件包含，宏展开的处理，删除注释内容，添加文件标识符和行号生成.i文件
- 编译：生成汇编代码。词法分析、语法分析、语义分析、源代码优化、目标代码生成、目标代码优化。

- 汇编：生成可重定位文件。生成机器码，为每个源码文件单独生成一个.o文件。同时会生成三张表，导出符号表，未解决符号表、地址重定向表。
  1. 导出符号表：该目标文件可以提供的符号及信息。
  2. 未解决符号表：即找不到地址的符号的列表，告诉链接器这些符号没找到地址。
  3. 地址重定向表：链接的时候，链接器会为目标文件的“未解决符号表”里的符号在其他目标文件中寻找地址，但是每个目标文件的地址都是从0x0000开始的。所以需要用一张地址重定向表记录符号相对自身文件的地址。
- 链接：生成可执行文件。符号决议、地址分配和申请空间、重定位。链接程序的主要工作就是将有关的目标文件（库文件、.o文件）彼此相连接，同时将在一个文件中引用的符号同该符号在另一个文件中的定义连接起来（符号重定向），使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。另外，静态库是在编译阶段链接到可执行文件的，函数的代码将从其所在的静态链接库中被拷贝到最终的可执行程序中，而动态库是在运行时再动态建立链接的。  
参考资料1：[C++编译过程](https://blog.csdn.net/csdn_violin/article/details/79430384)  
参考资料2：[值类型和引用类型背后的逻辑
](https://www.cnblogs.com/luoxiaofu/p/8528383.html)
