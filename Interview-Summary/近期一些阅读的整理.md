# 近期一些阅读的整理

#### 操作系统

1. 进程调度

   [进程、线程和协程的区别](https://blog.csdn.net/xiangxianghehe/article/details/80200522)

   [线程和进程的区别是什么？ - zhonyong的回答 - 知乎](https://www.zhihu.com/question/25532384/answer/81152571)

   线程为什么会出现资源竞争

2. 内存管理（虚存、块和页的概念）

3. [LRU](https://www.cnblogs.com/wyq178/p/9976815.html)，等常用算法（最近最久未使用算法，页面置换算法），SCAN（电梯算法）

   * LRU，最近最少用算法。元素加入链表前，判断链表元素是否已满，满则删除最后一个结点。然后查找链表中是否存在相同的元素，存在则把该元素删除，最后把新元素插入到链表的首部
   * LFU，最近不经常使用算法。把数据加入到链表中，按频次排序。发生淘汰的时候，把频次低的淘汰掉
   * 优化：用一个哈希表记录缓存，可以将插入，查找做到O（1）
   * [参考资料](https://www.jianshu.com/p/1f8e36285539)

#### 网络

1. OSI七层和TCP/IP四层

2. HTTPS的握手过程，HTTP和HTTPS的区别

   相比HTTP协议，HTTPS协议主要是多了SSL（记录协议，数据封装、压缩和加密）/TLS（握手协议，协商加密算法、身份认证、交换加密密钥）协议。

   HTTP和HTTPS的一些区别：

   * 证书

   * HTTP是超文本明文传输，HTTPS是ssl加密传输

   * 端口不一致

   * HTTP是无状态的，也是无连接的（借助于底层的TCP虚拟连接）

3. TCP的三次握手，四次挥手过程，TCP和UDP的区别

   三次握手交换序列号，四次挥手确保内容完整传输

   TCP协议的滑动窗口和拥塞控制保证可靠传输和流量控制

   TCP和UDP的一些区别

   * TCP面向连接，建立和释放连接都需要双方彼此通信
   * TCP和UDP都支持全双工服务，但TCP支持字节流传输，UDP支持报文传输
   * TCP可靠传输：校验和和确认机制检查数据安全，拥塞控制和重传功能
   * 相对的，UDP是一种无连接、不可靠、面向报文的传输层协议，对报文提供了可选的校验和保证数据正确性外，如果检测到收到的分组有差错就丢掉这个分组
   * UDP支持一对一、一对多和多对多的交互式通信（支持广播？），而TCP只支持一对一的单播

4. HTTP/1.x和HTTP/2（基于SPDY，多路复用、二进制分帧、首部压缩、server push）

   HTTP/2拥有和HTTP1相同的请求格式，但得到了很大的优化：多路复用，服务器Push

5. HTTP/3（基于UDP的QUIC，完美解决队头堵塞，0RTT建连——解决TCP+TLS建立连接的延时）做了哪些优化

   QUIC借助了UDP的优点，同时做了什么优化。QUIC在UDP基础上增加了一层保证数据的可靠传输。集成TLS，解决加密问题。多路复用，同一物理连接上可以有多个独立的逻辑数据流，避免队头阻塞。

   [参考资料](https://blog.csdn.net/howgod/article/details/102597450)

6. 网络层的路由选择和分组转发、IP协议解析（ARP地址解析协议）

7. 非对称加密算法：RSA、ECC和DH

   双方互相持有对方的公钥和自己的私钥。如何验证公钥和私钥的正确：CA。RSA原理：两个大素数作为私钥，而大素数的乘积作为公钥，因为大素数相乘是十分容易，而对乘积进行因式分解却很难。

   [参考资料](https://blog.csdn.net/u014294681/article/details/86705999)

ARC协议根据IP确定相邻目标主机的MAC地址，DNS根据域名解析出对应的IP地址

PS： 参考网络部分笔记，参考链接：

**补缺：iOS网络编程实践，多线程GCD，加密部分知识**

#### 算法

主要参考编程之美，剑指Offer，LeetCode。注：跳楼梯算法，[股票最大收益问题](https://segmentfault.com/a/1190000006672807)

##### 查找和排序

十种排序算法，静态查找和动态查找

##### 一些结构

###### 哈希表

###### 平衡二叉树

高度差小于等于1的二叉排序树。左子树结点总是小于当前节点，右子树节点总是大于等于当前结点。在插入和删除结点时，如果不符合平衡性要求，需要重新调整树。

###### 红黑树

1. 约束：平衡二叉树的一种变体，但高度差有可能大于1。

   结点为黑色或红色；根结点和叶子结点为黑色；红结点的两个子结点都是黑色的。

   所有叶子结点到根结点的路径不能存在连续的两个红色结点；从任一结点到每个叶子结点的所有路径都包含相同的黑色结点。

2. 这些约束决定了红黑树，从根结点到叶子结点的最长的可能路径不多于最短的可能路径的两倍长，因此这个树大致上是平衡的。这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，因为这里的性能取决于查找的效率。
3. 插入和删除结点后，为了不违背红黑树的性质，我们需要对相关结点做一系列的调整。通过对树进行旋转，修改树中某些结点的颜色和指针结构，以达到插入和删除操作完成后仍保持红黑树特有性质的目的。
4. 插入结点时，首先根据一般二叉查找树的插入步骤插入，然后把插入结点着色为红色，判断是否需要调整，需要则对有关结点重着色并旋转。如果插入是黑色会破坏所有路径黑色数量一致的约束。
5. 删除结点和插入结点算法大体上一致。如果删除结点时红色，不需要做任何操作，红黑色属性未被破坏。
6. 插入和删除结点的时间复杂度都是O(log n)。应用：Linux系统中的部分任务调度和虚拟内存场景中，数据库的索引机制

###### 字典树

#### iOS

对于OC和跨平台的了解

主要围绕关键字、动态特性和其它一些跨端技术方案

1. [了解OC语法]()

   OC有哪些属性关键字：原子性：atomic、nonatomic；读写性：readwrite，readonly；内存管理：assign，strong，weak，unsafe_unretained，copy（生成拷贝）；方法名：getter，setter

   在ARC下，基本数据类型默认的关键字是：atomic，readwrite，assign

   普通Objective-C对象默认关键字是：atomic，readwrite，strong

   [了解OC中属性和成员变量](https://www.jianshu.com/p/562950427717)

2. [了解Flutter的一些机制]()

##### # 对于Swift的了解

类型安全（编译器类型检查，类型推断，不支持隐式类型转换）的静态语言。

1. Swift和OC的区别和联系：[有侧重点地区分Swift和OC](http://www.cocoachina.com/cms/wap.php?action=article&id=26989)
2. [中文版Apple官方Swift教程](https://swiftgg.gitbook.io/swift/)
3. [值类型和引用类型](https://swifter.tips/value-reference/)——有意思的是，Swift中的所有内建类型都是值类型，不仅包括传统意义像Int，Bool这些，甚至连String，Array以及Dictionary都是值类型的，这在程序设计上绝对算得上一个震撼的改动。并且值类型的内容移动机制是写时复制。将Array和Dictionary设计为值类型的考虑，最大的考虑是为了线程安全，但这样的设计在存储内容较少时也为我们带来了另一个优点，就是非常高效。
4. [泛型约束、关联类型](https://swiftgg.gitbook.io/swift/swift-jiao-cheng/22_generics#associated-types)、类型擦除
5. 怎么实现链式编程

##### 基础知识

1. [响应链和传递链](https://gsl201600.github.io/2019/12/25/iOS%E4%B8%AD%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%93%8D%E5%BA%94%E9%93%BE%E5%92%8C%E4%BC%A0%E9%80%92%E9%93%BE/)
   * 事件传递过程中，通过调用UIView的hitTest检测是否在子view上，在hitTest方法中首先调用pointInside判断触摸点point是否在当前UIView上，在则遍历它的子视图来查找最终响应的子视图。
   * 事件响应过程中，如果View的控制器存在，传递给控制器处理，否则传递给它的父视图，一直传递上去，如果UIApplication也不能处理该事件，则将该事件丢弃。

2. App内通信方式：Delegate、Notification和KVO

3. MVC和MVVM模式
   * [MVC和MVVM的那些事](https://www.jianshu.com/p/caaa173071f3)，本文中博主提出了MVC的缺点，并且指出在现实的MVC中，很多时候开发者连MVC都没有遵守
   * [MVC瘦身](http://blog.devtang.com/2015/11/02/mvc-and-mvvm/)：唐巧在这篇博客中提供了MVC的瘦身思路，并指出了MVVM的一些不足。

5. [第三方库的使用]()

##### Swift底层和特性探索

1. [Property Wrapper的使用]()

2. [Swift底层探秘——从Iterator到Collection]()

3. [Swift的静态派发和动态派发机制](https://juejin.im/post/6844904120810209294)

   为什么分配在栈上面的值，相对于分配在堆上面的值而言，是线程安全的

4. [Swift进阶之内存模型和方法调度](https://blog.csdn.net/hello_hwc/article/details/53147910)

5. [深入理解Swift派发机制](https://kemchenj.github.io/2016-12-25-1/) 

   常见的派发机制一般包括直接派发，函数表派发和消息转发，在Swift内部这三种派发机制都有使用。对于Swift的派发机制，我们认为有下面几个会影响到选择具体派发方式的因素：声明的位置，引用类型，特定的行为，显式地优化。有几个要点我们需要注意：1.在类型声明的作用域内声明方法和在extension内声明方法时，除了值类型，其它在两种情况下会使用不一样的派发机制。2.当协议拓展和类型拓展同时实现了同一函数时，使用协议类型调用方法时，可能会调用协议拓展的实现（根据协议中函数的声明位置确定）。3.Swift中可以通过final、dynamic，@objc等修饰符指定派发方式。4.Swift的自动优化和带来的一些问题。![派发机制总结](https://tva1.sinaimg.cn/large/007S8ZIlgy1giossmt012j311e0imwjm.jpg)

6. [Swift的不安全性]()

##### 编译原理

1. [怎么写一个解释器](http://www.yinwang.org/blog-cn/2012/08/01/interpreter)

   解释器和编译器的区别

##### # 内存机制

iOS的引用计数机制，引用循环的分析和解决（内存泄漏）。引用计数的底层实现机制（Side Table等）

1. ARC引用计数原理解析

   [iOS引用计数管理之揭秘计数存储](https://www.jianshu.com/p/17817e6efaf5)——本文详细探索了引用计数存储在哪里，在某些情况下它直接存储在isa.extra_rc中，但有时候它是存储在sidetable中，或者两者中都存在，可以作为下文中强引用部分的扩展阅读。

   [理解ARC实现原理](https://juejin.im/post/6844903847622606861)——通过这篇文章，我们可以了解strong、weak和autorelease修饰符在底层的实现

   对于强引用的引用计数管理，我们只是通过变量记录引用的数值：

   * 引用计数分别存储在isa的extra_rc和sidetable中，当isa.extra_rc溢出时，会转移一半引用计数到sidetable。

   对于弱引用的管理，我们可以通过以下步骤实现弱引用的持有和释放：

   * objc 运行时维护了一个全局的SideTables散列表，key为弱引用变量指向的对象地址，键值value为弱引用表weak_sidetable_t，可能出现哈希冲突，冲突时多个对象共享一个weak_sidetable
   * 取得的weak_sidetable也是一个散列表，key仍是弱引用变量指向的对象地址，键值为weak_entry散列表，对于出现的哈希冲突，我们使用线性探测方法解决
   * weak_entry保存了指向对象的弱引用，数量较小时使用数组存放，数量较大时同样适用哈希表存放，哈希表负载超过3/4时进行扩容

   对于autorelease的引用计数管理

   * ARC环境下，autorelease修饰符可以将对象加入自动释放池中，由自动释放池管理释放
   * autoreleasepool由一个或多个autoreleasePoolPage组成，page的大小为4KB，他们通过parent和child指针组成一个双向链表。剩下包括hotPage、coldPage、POOL_BOUNDARY和next指针等概念。
   * 对象按以下逻辑判断加入：如果hotPage存在且未满，加入hotPage；如果hotPage存在且已满，尝试加入其它未满page，未找到则新建page并插入；hotPage不存在，则直接新建Page并插入。

2. runtime原理

   * 主要可参考冬瓜的[runtime源码解析](https://www.desgard.com/iOS-Source-Probe/)，这是冬瓜写的一本电子书，主要围绕iOS系统库、底层实现和第三方库等的源码实现进行了探索。收集这本书的目的除了学习外，也是为了提醒自己向冬瓜大佬看齐，多看源码和底层实现原理。

   * [runtime原理](https://juejin.im/post/6844903536103260168)

     * 了解OC中的一些基础数据结构，包括以下：

       * id
     
       * Objc_object
       
       * Class(objc_class)
       
       * Meta Class(元类)
       
       * Category
       
         Category可以参考这篇文章：[runtime原理笔记](https://zhang759740844.github.io/2016/08/22/runtime)看下，文章主要围绕Category为什么添加实例变量失败出发，探讨了runtime的实现和使用。
       
       * SEL
       
       * Method
       
       * Ivar
       
       * Objc_property_t
       
       * IMP
       
       * Cache
       
       * Protocol?![img](/Users/ws/Documents/GitHub/LearningNote/方法查找.png)
     
     superclass指针代表继承关系，isa指针代表实例所属的类。 类也是一个对象，它是另外一个类的实例，这个就是“元类”，元类里面保存了类方法的列表，类里面保存了实例方法的列表。实例对象的isa指向类，类对象的isa指向元类，元类对象的isa指针指向一个“根元类”（root metaclass）。所有子类的元类都继承父类的元类，换而言之，类对象和元类对象有着同样的继承关系
     * Category分类
     
     * 发送消息和消息转发
     
       如果自底向上，最后仍没有找到与选择子SEL名称相符的方法，就会执行消息转发。
     
       消息转发的步骤基本可分为：
     
       * 动态方法解析
       * 备用接收者
       * 完整转发
     
     * 动态方法解析
     
       找不到SEL对应方法会执行消息转发，消息转发的第一步就是动态解析。
     
     * 关联对象（Associate Object）
     
     * 交换方法（Method Swizzing）
     
       [runtime原理和实践：方法交换篇](https://www.jianshu.com/p/6bcff1f9feee)
   
3. [runloop原理](https://juejin.im/post/6844903604965523464#comment)

   * 线程和runloop是一一对应的，其关系保存在一个全局的DIctionary里。手动创建的线程默认没有开启runloop，Runloop的创建发生在第一次获取时，runloop的销毁发生在线程结束时

   * 对于主线程来说，runloop在程序一启动就默认创建好了。另外，你只能在一个线程的内部获取其Runloop（主线程除外）

   * 但在子线程使用Timer时，一定要先确保子线程开启了runloop（且runloop中的mode添加了item维持runloop的事件循环），否则timer的回调不会执行

   * runloop在每个事件循环结束后会去自动释放池将所有自动释放对象的引用计数减一。

   * 

   * [深入理解runloop](https://blog.ibireme.com/2015/05/18/runloop/)

     Core Foundation中关于Runloop有五个类：CFRunloopRef、CFRunloopModeRef、CFRunloopSourceRef、CFRunloopTimerRef、CFRunloopObserverRef，它们的关系如下图所示：

     ![RunLoop_0.png (910×714)](https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_0.png)

     runloop的内部执行逻辑：
     
     ![RunLoop_1.png (1294×996)](https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_1.png)

4. [block原理](https://gsl201600.github.io/2020/05/13/iOSblock%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/)，[深入研究Block捕获外部变量和__block实现原理—霜神](https://halfrost.com/ios_block/)

5. [GCD原理详解](http://chuquan.me/2018/12/01/gcd-introduce/)

6. [苹果iOS系统源码思考](https://juejin.im/post/6844903639094394893)

#### 项目

在项目里主要做了什么

1. 完成文件保存和同步模块，支持离线模式下对文件操作，实现缓存管理避免文件丢失

   * 文件保存流程

     直接覆盖原文件——新的文档生成成功才删除原文件——保存后原文件缓存到cache中

     保存的判断，判断是否进行保存的条件设定

   * 文件同步流程

     手动保存同步时直接比对，处理冲突（冲突不应直接覆盖本地），返回云文件后刷新同步，应用相同规则，并做好

   * 缓存管理和清除（避免文件丢失的方法）

     管理本地文件/文件夹的状态，tag信息，缓存最近浏览记录

2. 实现会员管理模块，包括游客模式和离线下的会员状态管理
   * 离线下会员支持：编写了统一的会员管理模块，切换后台/登录/打开软件/保存/定时刷新用户的会员信息，判断时直接调用统一的判断接口
   * 游客模式的实现：实现用户游客态的管理，游客不使用云，会员功能提示购买会员，游客会员隐式绑定appid，登录后检测游客会员绑定

3. 实现异常收集和分析，包括友盟、Bugly的集成和自定义异常收集

   * 异常收集的原理

     拦截Unix信号和Mach异常并进行处理，可以参考淘宝技术之前分享的一篇崩溃捕获的文章，[Crash分析攻略](https://mp.weixin.qq.com/s/hVj-j61Br3dox37SN79fDQ)

   * 怎么分析一个异常，通过什么方法定位/修改，crash自动符号化平台的搭建。

   * 为了避免异常的发生应该做点什么

   * 自定义异常的用途和收集的内容

   * 成果：最终把崩溃率降到了0.0x%

4. 实现iOS端的适配，包 括不同机型适配，iPad键盘和界面适配，iOS13和iOS14适配解决（深色模式、AppleID登录、相册API的适配，编辑界面自定义主题颜色）
   * 适配遇到的一些特殊问题的处理：
   * 深色模式的适配和自定义颜色的方案比较
   * 相册API的适配和封装

5. 内存泄漏解决和内存占用优化

   * 编辑页强引用导致的内存泄漏，View层次的循环引用和迁移的核心库中存在的循环引用

     分析并处理了闭包中和view层面的循环强引用，部分内核库也修改了引用方式

   * 内存占用，绘制的区域尺寸过大

     缓存机制，切分绘制的块大小，按比例绘制导图，图片压缩，懒加载（懒加载的缺点）

   * tableview简单优化

     预加载，加载直接读取本地图片，优化图片大小。

     参考阅读：[深入剖析Swift性能优化](https://mp.weixin.qq.com/s/U95QmOOjeXkk-yC23cuZCQ)，[iOS卡顿优化](https://juejin.im/post/6844904004053368846)，[查看当前屏幕帧数工具的实现](https://www.jianshu.com/p/878bfd38666d)

6. 极难挑战的点

7. 对竞品的了解和分析

一些编程实践：

1. [一段代码的重构实践记录](https://juejin.im/post/5e01cb76f265da339260c753)
2. [Swift复杂视图多事件回调处理方案思考](https://www.jianshu.com/p/204e2d00c202)
3. [基于CoreText的排版实践](https://blog.devtang.com/2015/06/26/using-coretext-1/)

#### 自我学习和规划

最近我在写些什么，主要是个人学习笔记，在微信公众号、个人博客和Github发布。

未来个人规划：开一个项目，用上自己学习到的一些东西和实践一些想法

有看到哪些比较好的书：王巍的《Swift Tips》，《Adcance Swift》和戴铭的《iOS编程-理顺核心知识点》

知识的获取途径：技术社区或组织：老司机技术周报、SwiftGG、知识小集，掘金、微信公众号和小专栏等，一些个人博客，包括国外的博主。主要关注方面：iOS底层解析、编程实践，技术的更新（如Swift的新特性），另外，paul的课程还是停留在三分之二的进度，一直没看完…。

