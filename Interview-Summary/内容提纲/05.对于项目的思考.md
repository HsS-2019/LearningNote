## 对于项目的思考

在项目里主要做了什么

1. 完成文件保存和同步模块，支持离线模式下对文件操作，实现缓存管理避免文件丢失

   * 文件保存流程

     直接覆盖原文件——新的文档生成成功才删除原文件——保存后原文件缓存到cache中

     保存的判断，判断是否进行保存的条件设定

   * 文件同步流程

     手动保存同步时直接比对，处理冲突（冲突不应直接覆盖本地），返回云文件后刷新同步，应用相同规则，并做好

   * 缓存管理和清除（避免文件丢失的方法）

     管理本地文件/文件夹的状态，tag信息，缓存最近浏览记录

2. 实现会员管理模块，包括游客模式和离线下的会员状态管理

   * 离线下会员支持：编写了统一的会员管理模块，切换后台/登录/打开软件/保存/定时刷新用户的会员信息，判断时直接调用统一的判断接口
   * 游客模式的实现：实现用户游客态的管理，游客不使用云，会员功能提示购买会员，游客会员隐式绑定appid，登录后检测游客会员绑定

3. 实现异常收集和分析，包括友盟、Bugly的集成和自定义异常收集

   * 异常收集的原理

     拦截Unix信号和Mach异常并进行处理，可以参考淘宝技术之前分享的一篇崩溃捕获的文章，[Crash分析攻略](https://mp.weixin.qq.com/s/hVj-j61Br3dox37SN79fDQ)

   * 怎么分析一个异常，通过什么方法定位/修改，crash自动符号化平台的搭建。

   * 为了避免异常的发生应该做点什么

   * 自定义异常的用途和收集的内容

   * 成果：最终把崩溃率降到了0.2%

4. 实现iOS端的适配，包 括不同机型适配，iPad键盘和界面适配，iOS13和iOS14适配解决（深色模式、AppleID登录、相册API的适配，编辑界面自定义主题颜色）

   * 适配遇到的一些特殊问题的处理：
   * 深色模式的适配和自定义颜色的方案比较
   * 相册API的适配和封装

5. 内存泄漏解决和内存占用优化

   * 编辑页强引用导致的内存泄漏，View层次的循环引用和迁移的核心库中存在的循环引用

     分析并处理了闭包中和view层面的循环强引用，部分内核库也修改了引用方式

   * 内存占用，绘制的区域尺寸过大

     缓存机制，切分绘制的块大小，按比例绘制导图，图片压缩，懒加载（懒加载的缺点），关闭后移除。

   * 部分列表页的内存峰值过高，且退出界面后内存没有降低

     解决方法：

     * 在退出时清除对应的内存缓存，滚动加载或进入时的加载按照缓存、本地、网络的顺序查询是否有对应图片并加载。
     * 通过网络下载的图片直接存到本地，不缓存到内存（避免峰值过高，滚动时再加载）。
     * 按图片显示的宽高压缩图片，使用下采样加载图片缩略图的方式减少图片的占用内存，缓存到本地的也是缩略图：
     * 可以把解码和下采样过程放到子线程（子线程串行队列异步执行，会放到后台解码，但是保证在同一线程），但不建议使用并发队列，可能会导致**线程爆炸**：当解码任务过多，GCD会开启过更多线程，导致每个线程获得更少的时间（线程切换也有代价）。
   
   * tableview简单优化
   
       预加载，加载直接读取本地图片，优化图片大小。
   
       参考阅读：
   
       * [深入剖析Swift性能优化](https://mp.weixin.qq.com/s/U95QmOOjeXkk-yC23cuZCQ)
   
       * [iOS卡顿优化](https://juejin.im/post/6844904004053368846)
   
       * [查看当前屏幕帧数工具的实现](https://www.jianshu.com/p/878bfd38666d)
   
6. OOM、FOOM和Jetsam机制

   BOOM一般指后台应用被jetsam机制kill掉，而FOOM指前台应用内存占用过大导致被强杀。

   iOS设备不存在交换区导致内存受限，为了保证使用体验，iOS内核会通过jetsam机制，监控并kill掉一些**优先级不高或占用内存过大**的进程。

   > 苹果依靠特有的jetsam机制检测和处理低内存事件，因为内存不足而导致App被kill的事件**无法被捕获**

   在BSD层创建了一个内核优先级最高的线程`VM_memorystatus`，这个线程会维护两个列表：一个是我们之前提到的基于进程优先级的进程列表（优先级队列）；还有一个是内存快照列表，即保存了每个进程消耗的内存页`memorystatus_jetsam_snapshot`。

   这个常驻线程接收**从内核对于内存的守护程序pageout（一个线程）通过内核调用给每个App进程发送的内存压力通知**来处理事件，**这个事件转发成上层的UI事件，就是我们平常收到的全局内存警告或者ViewController里的`didReceiveMemoryWarning`。**

   但我们的App是不会主动注册监听这个内存警告事件的，帮助我们在底层完成这一切的是`libdispatch`。`memorystatus_action_needed`中有提到哪些情况会出现内存压力：

   * 频繁地换进换出页面（`is_reason_thrashing`）。
   * `Mach Zone`耗尽了，这部分设计Mach内核的虚拟内存管理（`is_reason_zone_map_exhaustion`），这部分的虚拟内存管理是怎样的？
   * 可用的页低于阈值（`memorystatus_available_pages`）。

   出现这些情况，我们会经过一个对时间窗口的判断，看起来这个时间判断是为了在第一次出现上述的情况时，留出对应时间给相应App做点什么**（那应该有个途径通知到对应App？）**。满足时间窗口的需求后，系统会根据我们提到的优先级进程列表进行寻找可kill目标。需要注意的是，Jetsam不一定只kill一个进程。

   其实上面创建了两个内核优先级最高的线程，上面说的是低内存事件的常驻监控线程，另外一个是内存和进程的休眠事件的常驻监控线程。

   参考阅读：

   * [OOM内存abort原理探究](https://satanwoo.github.io/2017/10/18/abort/)
   * [iOS中OOM底层原理探究](https://jinxuebin.cn/2019/07/OOM%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86%e6%8e%a2%e7%a9%b6/)
   * [即刻内存管理研究](https://zhuanlan.zhihu.com/p/49829766)
   * [Reducing FOOMs in the Facebook iOS app](https://engineering.fb.com/ios/reducing-fooms-in-the-facebook-ios-app/)
   * [iOS微信内存监控](https://wetest.qq.com/lab/view/367.html)
   * [你真的了解OOM吗？——京东iOS APP内存优化实录](http://www.cocoachina.com/index.php/articles/485753)
   * 要区分iOS中的dirty memory和clean memory

   图像优化-简单阅读：

   * [iOS性能优化-Allocations 分析内存分配](https://mp.weixin.qq.com/s/WqVZ1rFpYrvE8X-J0f35mw)
   * [下采样](https://www.jianshu.com/p/7d8a82115060)
   * [iOS性能优化——图片加载和处理](https://www.jianshu.com/p/7d8a82115060)
   * [图像优化](https://nemocdz.github.io/post/%E8%AF%91-%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96/)

项目软技能：

1. 极难挑战的点/经历最难的业务开发

   最难的是云文件和内存优化这两个点

2. 最擅长iOS哪方面知识，怎么体现出来

   目前其实没有最擅长的，都是一些业务开发，但是在富文本编辑，还有图形绘制上面积累了一些经验，日常阅读对底层和问题定位也有一定的认识。

3. 做过什么工作职责之外的事情

   编码规范讨论，体验竟品，提一些创意的点或者需求，体验自家产品，发现bug。

4. 用过的开源库和原理了解

   SwiftLine，Alamofire，KingFisher，SnapKit

5. 对竞品的了解和分析

   Xmind，MindManager，幕布，石墨文档……

一些编程实践：

1. [一段代码的重构实践记录](https://juejin.im/post/5e01cb76f265da339260c753)
2. [Swift复杂视图多事件回调处理方案思考](https://www.jianshu.com/p/204e2d00c202)
3. [基于CoreText的排版实践](https://blog.devtang.com/2015/06/26/using-coretext-1/)