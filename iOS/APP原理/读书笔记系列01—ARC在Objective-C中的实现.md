# 读书笔记系列01—Objective-C中的内存管理（1）

学习内存管理知识有利于我们编写出更高质量的代码。不同于C++中的手动管理内存，和Java中的垃圾回收机制，苹果在Objective-C和后来推出的Swift中都采用了自动引用计数机制（ARC），方便编译器进行内存管理。值得一提的是，C++ 11也引进了智能指针的概念，而智能指针的原理正是自动引用计数。

> ARC，自动引用计数（Automatic Reference Counting）的缩写，是指在内存管理中对引用采取自动计数的技术。

在学习ARC之前，我们首先通过一个例子，了解一下**引用计数**是什么意思。

## 认识引用计数

假设有一个只有一盏灯的教室，为了保证教室里有人的时候，灯必须开着照明，因此要求班上来的最早的同学需要开灯，班上走的最晚的同学需要关灯。而为了判断教室里是否还有同学，这里引入了引用计数的概念来计算“教室里还有多少同学”。

- 第一个同学进入教室，“教室里的同学数量”加1，数值从0变为1，因此需要开灯
- 之后，每当有同学进入教室，“教室里的同学数量”就加1
- 每当有同学离开教室，“教室里的同学数量”就减1
- 当最后一个同学离开教室后，“教室里的同学数量”变为0，因此需要关灯

在这个例子里，我们简单了解了引用计数的工作原理。回到Objective-C中，类比一下，可以发现其实对象就相当于教室里的灯，而教室里的同学就相当于持有该对象的实例。而在Objective-C中，概括来说，我们主要是通过以下四个对对象的操作实现内存管理。

- 生成并持有对象
- 持有对象
- 释放对象
- 废弃对象

这里可以通过下面的一张表，更好地理解不同操作所代表的含义。

|对象操作		|对象的状态						    |对应例子        |
|:-----------	|:-----------------------------|:-------------|
|生成并持有对象	|申请内存，对象的引用计数从0变为1   |开灯           |
|持有对象 		|对象的引用计数加1				    |教室里同学数量加1|
|释放对象		|对象的引用计数减1				    |教室里同学数量减1|
|废弃对象		|对象的引用计数变为0时，销毁对象    |关灯           |

## Objective-C中的引用计数

在上文中，我们了解到，Objective-C主要通过四个对对象的操作来实现引用计数式内存管理。可是对于这些操作，我们似乎并不确定应该按照怎样的顺序来使用；或者说怎么教会计算机，什么时候应该执行哪个操作，从而得到一个健壮性良好的系统/机制。这需要更具体的设计，也是我们所需要思考的方向。

为了后面的使用方便，在这里列下Objective-C中这四个对象操作的对应方法

|对象操作		|对应的Objective-C方法		     |
|:-----------	|:------------------------------|
|生成并持有对象	|alloc/new/copy/mutableCopy等方法|
|持有对象		|retain方法					     |
|释放对象		|release方法					     |
|废弃对象		|dealloc方法					     |

需要注意的是，这些内存管理方法都是包含在Cocoa框架的Foundation类库中，实际上不包括在Objective-C这门语言上。而本文中的对象，如无特别说明，一般指的是`NSObject`类的对象或继承自`NSObject`类的子类对象。

### 设计中的四条规则

顺着上面的方向思考，我们可以得到四条比较明显的规则。

- 自己生成的对象，自己所持有
- 非自己生成的对象，自己也能持有
- 不再需要自己持有的对象时释放
- 非自己持有的对象无法释放

#### 1. 自己生成的对象，自己所持有

在Objective-C中，使用以下名称开头的方法意味着自己生成的对象只有自己所持有

- alloc
- new
- copy
- mutableCopy

使用上面的四个方法其实都能自己生成并持有对象，但这四个方法的用法并不太一样。在`NSObject`类中，我们常通过`[[NSObject alloc] init]`的方式声明并初始化一个`NSObject`对象，这与`[NSObject new]`方法的效果一致，但`alloc`方法只是创建了对象，并把指向生成并持有对象的指针赋给对应的变量，而不能对对象进行初始化。

`copy`方法和`mutableCopy`方法都**有可能**生成并持有对象的副本，用这些方法生成的对象，虽然是对象的副本，但同样属于自己生成并持有对象。这里需要注意的是，`copy`方法和`mutableCopy`方法生成并持有对象的副本指的是发生了深拷贝，但在某些情况下其实不会发生深拷贝的，对这里感觉有问题的可以参考一下[这篇博客](https://juejin.im/entry/57b15244a633bd00570955be)。

根据上述“使用以下名称开头的方法名”，下列名称代表的方法也意味着自己生成并持有对象

- allocMyObject
- newThatObject
- copyThis
- mutableCopyYourObject

但是对于下列名称，即使用alloc/new/copy/mutableCopy名称开头，也并不属于同一类方法

- allocate
- newer
- copying
- mutableCopyed

当对象被声明出来时（申请内存），因为一开始就把指向生成并持有对象的指针赋给了一个实例变量/常量，相当于第一个同学进入了教室，所以该对象的引用计数从0变为1。

```
/*
 *OC对象的声明和初始化
 */
id obj = [[NSObject alloc] init]
```

#### 2. 非自己生成的对象，自己也能持有

对于不是自己生成并持有的对象，对应类型的变量也可以指向并持有该对象，该对象的引用计数会继续+1，此时该对象的引用计数变为2。

```
/*
 * 取得非自己生成的对象
 * 此时instance仍未持有该对象
 */
id instance = obj

/*
 *执行完retain方法后
 *instance持有obj指向的对象
 */
[instance retain]
```

#### 3. 不再需要自己持有的对象时释放

对于自己持有的对象，一旦不再需要，持有者有义务释放该对象，释放后，该对象的引用计数也会-1，此时该对象的引用计数变为0。

```
/*
 *instance不再需要持有该对象，释放对象
 */
 [instance release]
```
#### 4. 无法释放非自己持有的对象

当持有者已经释放了自己持有的对象时，该持有者不可再次调用`release`二次释放同一对象

```
 /*
  *当不再需要使用obj操作该对象时
  *obj也需要释放对象
  */
  
 [obj release]

/*
 *对象已释放
 */
 
 [obj release]
 
/*
 *释放之后再次释放已非自己持有的对象
 *应用程序会出现崩溃（crash）
 */
```

### 回收对象内存
最后当对象的引用计数变为0时，为了节省内存空间，销毁对象，回收对象内存。

```
/*
 *在规则3的示例中释放了对象之后
 *该对象的引用计数已经变为0
 *系统调用dealloc方法废弃对象，回收对象内存
 *开发者可以重写该方法，但不能手动调用
 */
```

### 引用计数的实现

这部分我们主要探讨引用计数在GNU框架和Apple的Cocoa框架中的实现。

苹果虽然开源了Core Foundation框架和rumtime部分源码，但是包含NSObject类的Foundation框架却是没有公开的，所以我们很难去了解到NSObject类的内部实现。因此在下面个别部分的实现我们会比较开源框架GNUstep进行说明。

#### 在GNUstep框架中的实现

GNUstep是Cocoa的互换框架，也就是说，GNUstep的源码虽不能说与苹果的Cocoa框架实现完全一致，但从使用者角度来看，两者的行为和实现方式是一样的，或者说是非常相似的。因此了解了GNUstep源码的也就相当于了解了苹果的Cocoa实现。

#### 苹果的实现
- Apple，散列表（哈希表），根据变量指向的地址，得到一张散列表（**重点**）

#### 两者的对比
- 两者的对比

## 了解MRC

从上面的描述中，我们学习了什么是引用计数，看起来这个东西还挺简单的吧，是的你没看错，好的技术本来就是简洁而又巧妙的（虽然我上面写了挺多，但是它的确挺简单的🤣）。为了更好地理解引用计数，下一步，我们深入一点了解其中的一些细节，其中包括思考这几个问题：

1. 申请内存和初始化时怎么实现的呢？
2. 引用计数从0到1这个阶段发生了什么？
2. 加1操作和减一操作又是怎么实现的呢？
3. 当引用计数变为0时，发生了什么？在什么时候发生的？

要解决上述的问题，我们先了解一下MRC，毕竟在早期的Objective-C程序中，我们都是使用MRC来手动管理对象的引用计数。

>MRC，在ARC出现之前，Objective-C早期使用的是一种叫做MRC（Mannul Reference Counting）的手动管理内存的机制。通过键入上面所提到的retain、release、autorelease、retainCount等方法，开发者们能够手动控制对象引用计数的加1、减1等操作。

内存管理是一种繁琐的工作，即使引入了引用计数这一简洁的概念，我们仍要添加许多管理引用计数的代码，以确保对象在不被使用的情况下及时被释放，避免内存泄漏。

### 与Objective-C内存管理有关的一些方法

#### alloc方法

#### retain方法

#### release方法

#### delloc方法

#### retainCount方法

#### autorelease方法

- Apple的实现
- autoreleasePool
- dealloc在什么时候执行

# ARC的实现

那么有没有更好的办法呢？毕竟要是没严格按照如下规范编写，漏了一个release都会觉得头大。

1. 谁创建的谁release 
2. 谁retain谁就release

作为开发者，对于这种麻烦的工作，我们应该想办法避免，把工作交给机器自动完成，进而达到解放双手，将更多精力放到思考（<del> 摸鱼 </del>）上面。

我要说的是：有的！


### 参考资料

- [《Objective-C 高级编程 ——iOS与OSX多线程和内存管理》]()
- [runtime源码（objc4-750）](https://opensource.apple.com/source/objc4/objc4-750/)