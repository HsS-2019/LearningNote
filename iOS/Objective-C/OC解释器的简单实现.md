# 认识解释器以及OC解释器实践

本篇文章的内容基于**《跟戴铭学iOS编程》**一书中的OC解释器实现部分。简单阐述了**解释器的工作原理**和**OC解释器的简单实现**。希望通过对这一部分知识的整理和思考，更深入地了解解释器的工作机制。

## 解释器做了什么

从计算理论的角度讲，每个程序都是一台机器的“描述”，而解释器是在“模拟”这台机器的运转，也就是在进行“运算”。通过解释器，我们可以把源代码解释执行，得到最终的运算结果。

解释器又称为**直译器**，能够把解释型编程语言一行一行地直接转译执行。解释器不会通过把所有源代码生成可执行程序的方式执行，而是像一个“中间人”，每次运行程序都要先转成另一种语言再运行。

一个解释器可大可小，大可以是复杂的编译器，小也可以是一个简单的字符串解析，但本质上它们都是**对特定的语法做出合理的解释。**

## 解释器的工作原理

本部分介绍了编译器和解释器的大概流程，比较和编译器和解释器的区别，并阐述解释器的不同运行方式，希望通过这一部分内容对解释器的工作原理有更深的了解。

### 了解编译器和解释器

现代运行程序的两种方式，一种是编译运行，另一种是解释执行，前者依赖于编译器把源代码编译成可执行程序，后者依赖于解释器直接转译执行。

#### 认识编译器

编译型语言需要**编译器处理**，主要的工作流程如下：

![image-20200827234537125](https://tva1.sinaimg.cn/large/007S8ZIlgy1gi5svto5vuj312c08imxs.jpg)

在这个过程中，编译器调用预处理器，**将源代码进行预处理**（清除注释、宏定义、包含文件和条件编译）。通过把经过**预处理的源代码编译成目标代码**（二进制机器语言），再**调用链接器外加库文件，从而形成可执行程序**，让机器能够执行。

需要注意的是，编译过程中，编译器会**针对不同的CPU架构和操作系统进行编译**，这样才能在特定的机器上运行程序。所以最后编译得到的目标代码会和机器的CPU架构相匹配，库文件会和操作系统相匹配。

#### 认识解释器

解释型语言可以通过**解释器处理**，主要工作流程如下：

![image-20200827234844533](https://tva1.sinaimg.cn/large/007S8ZIlgy1gi5syxgr0uj30fk07o3yn.jpg)

在这个过程中，源代码**无需预先编译**成可执行程序，在程序执行的过程中，解释器**每读取一句源代码**，会**对源代码进行词法分析和语法分析**，再**将源代码转换为解释器能够执行的中间代码**（例如字节码），最后，由解释器**将中间代码解释为可执行的机器指令**。

#### 解释器和编译器的区别

编译器和解释器各有优缺点，在执行效率上，解释器低于编译器，但在跨平台支持上，解释器又优于编译器。下面是他们的一些比较：

* 运行时机的不同

  解释器立即执行程序，在运行时解释器逐句代码解释成机器指令并执行（或者把中间代码解释执行），编译器为稍后的执行准备好可执行程序。

  即编译器生成一个独立的可执行程序，**程序的编译和执行是独立的两个阶段**。而解释的程序总是需要解释器来执行，**源代码的解释和执行是同一阶段**。

* 执行效率的不同

  编译型语言在经过编译后，得到可执行程序，可执行程序产生的是可直接执行的机器指令。而解释型语言需要在运行过程中逐句把源代码通过解释器解释为可执行的机器指令，所以**解释型语言的执行效率会比编译型语言的执行效率低。**

* 跨平台的支持性不同

  由于编译器的产物是可执行程序，所以**只能在某个特定平台上运行**，不同的操作系统和不同处理器需要不同的编译版本。

  而解释器解释程序，**可以在不同平台上使用相同的副本**，只需要一个能在特定平台上运行的解释器，所以**可以分发源代码或中间产物**。

  这是一个技术上的区别，其结果是**解释器编程语言更容易制作跨平台程序**。不过我们需要注意到**每个平台存在的一些细小的差异性**，这会让我们在编写跨平台程序时，针对不同系统在源代码上作出一些修改。例如目录分隔符在不同系统上表现形式可能不一致，还有部分函数可以在一个系统上使用，而在另一个系统上不支持等。

* 静态编译无法针对运行时的热点代码做对应优化

  **静态编译无法完全推断哪些代码是运行时的热点代码**，所以无法作出针对性的优化。而**JIT即时编译可以针对频繁被调用的热点代码做出深度优化**，因此通过JIT即时编译器编译的本地机器指令会比直接生成的本地机器指令拥有更高的执行效率。

* Debug的支持性

  在使用解释器比使用编译器时，调试更容易。

  一方面是**解释器只有一个可执行文件**，不需要开发的调试版本，也不需要最终用户的发行版本。而且解释器的**平台特定错误较少**。

  另一方面是解释器即时转换代码，**源代码中的信息仍然可用**，且**解释器一次执行一个语句**，因此更容易发现错误。

* 一个可能的考虑：内存限制

  部分观点认为，当程序运行环境中**内存资源限制较大**，可以使用解释器执行节约内存，反之可以使用编译执行来提升效率。但是这里有一个问题，嵌入式设备应该是符合内存资源限制较大这一场景的，但嵌入式通常是采用C/C++这类编译型的编程语言？

### 解释器运行方式

解释器通过**词法分析**和**语法分析**后**建立抽象语法树**，并进行静态分析。在静态分析通过后，解释器可以通过对抽象语法树（AST树）进行解析，将特定语言的实现。

解释器运行程序的方法有：

* 直接解释运行：直接运行高级编程语言
* 生成字节码：转换高级语言
* JIT编译后程序：以解释器包含的编译器对高级语言编译，并指示处理器运行编译后的程序

#### 直接运行高级编程语言

直接把高级编程语言的源代码转译成机器语言执行。

#### 

#### 字节码

第一次翻译时，吧源代码完整地进行转换，编译成更高效的字节码。如果后续源代码文件没有修改，就直接将对应字节码直接翻译成机器指令执行，从而提高速度。

#### JIT即时编译

对于重复的内容，翻译一次后就把它保存，再后续再次编译时，如果碰到相同的内容就直接使用保存的翻译结果，而无需每次都重新翻译。重复内容包括多次调用的方法体和多次执行的循环体。

## OC解释器的设计与实现

更类似于伪代码解释器，是先将程序的源代码转化为某种与机器无关的中间代码，然后再执行中间代码。而一般的源代码解释器不需要一个独立的编译过程，每次读入一条语句，并且根据这条语句执行特定的操作，以此类推。

本文中，我们使用Swift实现了一个OC解释器，往解释器输入一段OC实现的源代码，通过解释执行，得到代码的运算结果。在这个解释器中，我们去掉了很多OC语言的复杂语法和特性。

实现的OC解释器虽然过于简单，但并不影响我们的学习，相反，我们应先确保简单的功能实现正确，后续可以慢慢加入其它元素。

表达式解析器——

### 一些数据模型的约定

* OCToken类的设计

* OCAST抽象语法树节点的设计

### 词法分析器的实现

* 设置过滤规则
* 遍历文本
* 切Token
* 根据不同类型的token，进行对应处理

### 语法分析器的实现

* 根据token有序集合，生成对应的AST节点，并构建AST语法树
* 对应节点的处理，例如操作节点
* 优先级规则的加入，例如按优先级运算

### 静态分析器的实现

通过静态分析器，我们可以分析输入的OC代码是否合法，代码中的变量是否在使用前已经初始化，以避免导致奇怪的后果。

* 使用访问者模式的考虑
* 静态分析器中多级符号表的建立与更新
* 符号表元素的数据模型
* 符号表的相关操作

## 参考文章

* [解释器——百度百科]([https://baike.baidu.com/item/%E8%A7%A3%E9%87%8A%E5%99%A8/10418965?fr=aladdin](https://baike.baidu.com/item/解释器/10418965?fr=aladdin))
* [编译器和解释器的区别和工作原理](https://zhuanlan.zhihu.com/p/39141067)
* [编译器和解释器之间有什么区别](https://zhuanlan.zhihu.com/p/26838993)
* [怎么写一个解释器](http://www.yinwang.org/blog-cn/2012/08/01/interpreter)