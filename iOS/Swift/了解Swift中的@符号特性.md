在使用Swift进行日常开发的过程中，常常会发现会用到一些@符号，这些@符号在Swift4之前的版本大多是兼容OC的特性，但在Swift4及之后则出现越来越多搭配@符号的新特性。

##### @available

可用来标识计算属性、函数、类、协议、结构体、枚举等类型的生命周期（指定特定的平台版本、Swift版本）。作为条件语句的`available`前面是`#`，作为标记位时是`@`。

available后至少跟两个参数。第一个参数是固定的，表示平台或语言；后面参数的可选值包括下面这些：

* deprecated：从指定平台某个版本开始，废弃，但只是不推荐使用
* obsoleted：从指定平台某个版本开始，编译错误
* message：附加提示信息
* unavailable：在指定平台上无效，不被编译器联想
* renamed: 重命名声明

##### @discardableResult

带返回值的函数如果没有处理返回值会被编译器警告，但有时候我们就是不需要返回值，这时候可以在带返回值的方法前用`@discardableResult`标识符声明一下，如果别的地方没有处理该函数的返回值，编译器忽略这一类的警告。

##### @inlinable

这个关键词是可关联的声明，可用在方法、计算属性、下标、便利构造方法或者deinit方法中，把该结构声明为内联函数等，来源于C语言中的`inline`。因为声明为内联函数，所以会在编译时将该段函数调用用具体实现代替，这样可以省去函数调用的时间。

需要注意的是，内联声明不能用于标记为private或者fileprivate的地方。因为对私有方法的内联是没有意义的？

**关联知识点：Swift中的函数派发机制。**

##### @warn_unqualified_access

对“不合规”的访问进行警告。主要为了解决对于相同名称的函数，不同访问对象可能产生歧义的问题。例如系统库中定义的min函数和自定义类型中定义的min函数，如果在自定义类型内部没有使用min修饰而直接返回min的结果时，就会出现二义性问题。

## OC相关

##### @objc

可以把这个特性用到任何可以在`Objective-C`中的表示的声明上，objc特性告诉编译器，这个声明在`Objective-C`代码中是可用的。

用@objc特性标记的类必须继承自一个`Objective-C`中定义的类。标记为objc特性的协议不能继承自非`objc`特性的协议。

还有一个 用法是你想在`OC`的代码中暴露一个不同的名字时，可以用这个特性，解决潜在的命名冲突问题（因为`Swift`是有命名空间的，而`Objective-C`没有命名空间）。

##### @objcMembers

`Swift`中定义的方法默认是不能被`OC`调用的，除非我们手动添加`@objc`标识。但如果一个类的方法属性较多，为了方便，我们可以使用标识符`@objcMembers`，让整个类的属性方法都隐式添加`@objc`。当然，对于`OC`不支持的类型，仍然无法被`OC`调用。

##### @dynamic



---

##### @testable

用于测试模块访问主target的一个关键字，测试模块和主工程是两个不同的target。主工程不是对外模块，为了测试修改使用public和open这些访问权限是不应该的，所以使用@testable关键词。

##### @frozen和@unknown default

frozen意为冻结，向编译器保证之后不会再做出改变。和ABI稳定相关，可参考文章[ABI]()。冻结仅适用于结构体，对于class类型，不存在是否冻结的概念。

eg：对于没有标记为frozen的枚举类型，编译器认为该枚举值在之后的系统版本可能变化，所以我们在列出所有case的时候还需要加上对@unknown default的判断。

## SwiftUI中的@特性修饰词

##### @State、@Binding、@ObservedObject、@EnvironmentObject

## 特殊的特性修饰词

##### @propertyWrapper

属性封装器，可以方便地实现懒加载

## 一些常见的关键词

##### lazy

lazy是懒加载的关键词，当且仅当我们需要把初始化延迟到使用时才进行时，可以选用该关键词。对于Swift4.0以上版本，可以使用@propertyWrapper达到同样效果。

需要注意的是，lazy只能通过var初始化，let使用lazy关键字会报错。这是由lazy的具体实现细节所决定的：它在没有值的情况下以某种方式被初始化，然后在被访问时 改变自身的值，这要求该属性是可变的。

lazy也可以在序列中使用，例如arr.lazy.map，需要注意的是，这一类型的lazy只能用于map、flatMap、compactMap这种高阶函数中。

##### unowned weak

用于解决循环引用问题。相同声明周期使用unowned，其它使用weak。

#####  KeyPath

KeyPath是键值路径，最开始是用于处理KVC和KVO问题，后来又做了更广泛的扩展。